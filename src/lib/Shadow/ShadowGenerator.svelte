
			<script>
				import { onMount, onDestroy } from 'svelte'
				import { browser } from '$app/environment'
				import { bbLookup, bbIniting, bbDebug } from '$lib/stores.js'
				import * as BB from 'babylonjs'
				import { createEventDispatcher } from 'svelte'
				

				// ================ QUICKLOOK ================

				/* 
					mapSize  * required
					light  * required
					usefullFloatFirst  
					camera   
					customAllowRendering  
					customShaderOptions  
					enableSoftTransparentShadow  
					forceBackFacesOnly  
					frustumEdgeFalloff  
					id  
					onAfterShadowMapRenderMeshObservable  
					onAfterShadowMapRenderObservable  
					onBeforeShadowMapRenderMeshObservable  
					onBeforeShadowMapRenderObservable  
					useOpacityTextureForTransparentShadow  
				*/

				// ================ CONSTRUCTOR PROPERTIES ================

				
				export let mapSize = undefined // [number] * required
				// the size of the texture what stores the shadows. example : 1024.
				

				export let light = undefined // [ishadowlight] * required
				// the light object generating the shadows.
				

				export let usefullFloatFirst = undefined // [boolean] 
				// by default the generator will try to use half float textures but if you need precision (for self shadowing for instance), you can use this option to enforce full float texture.
				

				export let camera = undefined // [nullable] 
				// camera associated with this shadow generator (default: null). if null, takes the scene active camera at the time we need to access it
				

				// ================ CLASS INSTANCE ================

				export let instance = browser ? new BB.ShadowGenerator(mapSize,light,usefullFloatFirst,camera) : {}

				// ================ ACCESSORS ================

				
				export let bias = undefined // [number] 
				// 
				

				export let blurBoxOffset = undefined // [number] 
				// 
				

				export let blurKernel = undefined // [number] 
				// 
				

				export let blurScale = undefined // [number] 
				// 
				

				export let contactHardeningLightSizeUVRatio = undefined // [number] 
				// 
				

				export let darkness = undefined // [number] 
				// 
				

				export let depthScale = undefined // [number] 
				// 
				

				export let filter = undefined // [number] 
				// 
				

				export let filteringQuality = undefined // [number] 
				// 
				

				export let normalBias = undefined // [number] 
				// 
				

				export let transparencyShadow = undefined // [boolean] 
				// 
				

				export let useBlurCloseExponentialShadowMap = undefined // [boolean] 
				// 
				

				export let useBlurExponentialShadowMap = undefined // [boolean] 
				// 
				

				export let useCloseExponentialShadowMap = undefined // [boolean] 
				// 
				

				export let useContactHardeningShadow = undefined // [boolean] 
				// 
				

				export let useExponentialShadowMap = undefined // [boolean] 
				// 
				

				export let useKernelBlur = undefined // [boolean] 
				// 
				

				export let usePercentageCloserFiltering = undefined // [boolean] 
				// 
				

				export let usePoissonSampling = undefined // [boolean] 
				// 
				

				// ================ PROPERTIES ================

				
				export let customAllowRendering = undefined // [reflection] 
				// 
				

				export let customShaderOptions = undefined // [icustomshaderoptions] 
				// gets or sets the custom shader name to use
				

				export let enableSoftTransparentShadow = undefined // [boolean] 
				// enables or disables shadows with varying strength based on the transparencywhen it is enabled, the strength of the shadow is taken equal to mesh.visibilityif you enabled an alpha texture on your material, the alpha value red from the texture is also combined to compute the strength:         mesh.visibility * alphatexture.athe texture used is the diffuse by default, but it can be set to the opacity by setting useopacitytexturefortransparentshadownote that by definition transparencyshadow must be set to true for enablesofttransparentshadow to work!
				

				export let forceBackFacesOnly = undefined // [boolean] 
				// if true the shadow map is generated by rendering the back face of the mesh instead of the front face.this can help with self-shadowing as the geometry making up the back of objects is slightly offset.it might on the other hand introduce peter panning.
				

				export let frustumEdgeFalloff = undefined // [number] 
				// controls the extent to which the shadows fade out at the edge of the frustum
				

				export let id = undefined // [string] 
				// gets or set the id of the shadow generator. it will be the one from the light if not defined
				

				export let onAfterShadowMapRenderMeshObservable = undefined // [observable] 
				// observable triggered after a mesh is rendered in the shadow map.can be used to update internal effect state (that you can get from the onaftershadowmaprenderobservable)
				

				export let onAfterShadowMapRenderObservable = undefined // [observable] 
				// observable triggered after the shadow is rendered. can be used to restore internal effect state
				

				export let onBeforeShadowMapRenderMeshObservable = undefined // [observable] 
				// observable triggered before a mesh is rendered in the shadow map.can be used to update internal effect state (that you can get from the onbeforeshadowmaprenderobservable)
				

				export let onBeforeShadowMapRenderObservable = undefined // [observable] 
				// observable triggered before the shadow is rendered. can be used to update internal effect state
				

				export let useOpacityTextureForTransparentShadow = undefined // [boolean] 
				// if this is true, use the opacity texture's alpha channel for transparent shadows instead of the diffuse one
				

				// ================ METHODS ================

				
				export let addShadowCaster = (...args) => instance.addShadowCaster(...args)

				export let bindShadowLight = (...args) => instance.bindShadowLight(...args)

				export let dispose = (...args) => instance.dispose(...args)

				export let forceCompilation = (...args) => instance.forceCompilation(...args)

				export let forceCompilationAsync = (...args) => instance.forceCompilationAsync(...args)

				export let getClassName = (...args) => instance.getClassName(...args)

				export let getDarkness = (...args) => instance.getDarkness(...args)

				export let getLight = (...args) => instance.getLight(...args)

				export let getShadowMap = (...args) => instance.getShadowMap(...args)

				export let getShadowMapForRendering = (...args) => instance.getShadowMapForRendering(...args)

				export let getTransformMatrix = (...args) => instance.getTransformMatrix(...args)

				export let isReady = (...args) => instance.isReady(...args)

				export let prepareDefines = (...args) => instance.prepareDefines(...args)

				export let recreateShadowMap = (...args) => instance.recreateShadowMap(...args)

				export let removeShadowCaster = (...args) => instance.removeShadowCaster(...args)

				export let serialize = (...args) => instance.serialize(...args)

				export let setDarkness = (...args) => instance.setDarkness(...args)

				export let setTransparencyShadow = (...args) => instance.setTransparencyShadow(...args)

				export let Parse = (...args) => instance.Parse(...args)
				
				// ================ LIFECYCLE ================
				

				export let onMounted = () => {}
				export let onInited = () => {}
				export let onLoaded = () => {}

				const DEBUG = (...args) => $bbDebug ? console.log(`[${name}:ShadowGenerator]`, ...args) : null

				const self = !import.meta.env.SSR && arguments[0]
				$bbLookup.set( self, false )
				bbIniting.set( true )
				DEBUG('✨ initing')

				onMount( async e => {
					$bbLookup.set( self, true )
					DEBUG('🌱 mounted')
					let timeout = null
					onMounted(instance)
					const unsubscribe = bbIniting.subscribe( v => {
						if (timeout) clearTimeout( timeout )
						timeout = setTimeout( e => {

							$bbIniting = !Array.from($bbLookup.values()).every(v => v)
							DEBUG('🌿 inited')
							onInited(instance)

							if (!$bbIniting) {

												if (mapSize != undefined) instance.mapSize = mapSize?.instance || mapSize
				mapSize = instance.mapSize
				if (light != undefined) instance.light = light?.instance || light
				light = instance.light
				if (usefullFloatFirst != undefined) instance.usefullFloatFirst = usefullFloatFirst?.instance || usefullFloatFirst
				usefullFloatFirst = instance.usefullFloatFirst
				if (camera != undefined) instance.camera = camera?.instance || camera
				camera = instance.camera
				if (bias != undefined) instance.bias = bias?.instance || bias
				bias = instance.bias
				if (blurBoxOffset != undefined) instance.blurBoxOffset = blurBoxOffset?.instance || blurBoxOffset
				blurBoxOffset = instance.blurBoxOffset
				if (blurKernel != undefined) instance.blurKernel = blurKernel?.instance || blurKernel
				blurKernel = instance.blurKernel
				if (blurScale != undefined) instance.blurScale = blurScale?.instance || blurScale
				blurScale = instance.blurScale
				if (contactHardeningLightSizeUVRatio != undefined) instance.contactHardeningLightSizeUVRatio = contactHardeningLightSizeUVRatio?.instance || contactHardeningLightSizeUVRatio
				contactHardeningLightSizeUVRatio = instance.contactHardeningLightSizeUVRatio
				if (darkness != undefined) instance.darkness = darkness?.instance || darkness
				darkness = instance.darkness
				if (depthScale != undefined) instance.depthScale = depthScale?.instance || depthScale
				depthScale = instance.depthScale
				if (filter != undefined) instance.filter = filter?.instance || filter
				filter = instance.filter
				if (filteringQuality != undefined) instance.filteringQuality = filteringQuality?.instance || filteringQuality
				filteringQuality = instance.filteringQuality
				if (normalBias != undefined) instance.normalBias = normalBias?.instance || normalBias
				normalBias = instance.normalBias
				if (transparencyShadow != undefined) instance.transparencyShadow = transparencyShadow?.instance || transparencyShadow
				transparencyShadow = instance.transparencyShadow
				if (useBlurCloseExponentialShadowMap != undefined) instance.useBlurCloseExponentialShadowMap = useBlurCloseExponentialShadowMap?.instance || useBlurCloseExponentialShadowMap
				useBlurCloseExponentialShadowMap = instance.useBlurCloseExponentialShadowMap
				if (useBlurExponentialShadowMap != undefined) instance.useBlurExponentialShadowMap = useBlurExponentialShadowMap?.instance || useBlurExponentialShadowMap
				useBlurExponentialShadowMap = instance.useBlurExponentialShadowMap
				if (useCloseExponentialShadowMap != undefined) instance.useCloseExponentialShadowMap = useCloseExponentialShadowMap?.instance || useCloseExponentialShadowMap
				useCloseExponentialShadowMap = instance.useCloseExponentialShadowMap
				if (useContactHardeningShadow != undefined) instance.useContactHardeningShadow = useContactHardeningShadow?.instance || useContactHardeningShadow
				useContactHardeningShadow = instance.useContactHardeningShadow
				if (useExponentialShadowMap != undefined) instance.useExponentialShadowMap = useExponentialShadowMap?.instance || useExponentialShadowMap
				useExponentialShadowMap = instance.useExponentialShadowMap
				if (useKernelBlur != undefined) instance.useKernelBlur = useKernelBlur?.instance || useKernelBlur
				useKernelBlur = instance.useKernelBlur
				if (usePercentageCloserFiltering != undefined) instance.usePercentageCloserFiltering = usePercentageCloserFiltering?.instance || usePercentageCloserFiltering
				usePercentageCloserFiltering = instance.usePercentageCloserFiltering
				if (usePoissonSampling != undefined) instance.usePoissonSampling = usePoissonSampling?.instance || usePoissonSampling
				usePoissonSampling = instance.usePoissonSampling
				if (customAllowRendering != undefined) instance.customAllowRendering = customAllowRendering?.instance || customAllowRendering
				customAllowRendering = instance.customAllowRendering
				if (customShaderOptions != undefined) instance.customShaderOptions = customShaderOptions?.instance || customShaderOptions
				customShaderOptions = instance.customShaderOptions
				if (enableSoftTransparentShadow != undefined) instance.enableSoftTransparentShadow = enableSoftTransparentShadow?.instance || enableSoftTransparentShadow
				enableSoftTransparentShadow = instance.enableSoftTransparentShadow
				if (forceBackFacesOnly != undefined) instance.forceBackFacesOnly = forceBackFacesOnly?.instance || forceBackFacesOnly
				forceBackFacesOnly = instance.forceBackFacesOnly
				if (frustumEdgeFalloff != undefined) instance.frustumEdgeFalloff = frustumEdgeFalloff?.instance || frustumEdgeFalloff
				frustumEdgeFalloff = instance.frustumEdgeFalloff
				if (id != undefined) instance.id = id?.instance || id
				id = instance.id
				if (onAfterShadowMapRenderMeshObservable != undefined) instance.onAfterShadowMapRenderMeshObservable = onAfterShadowMapRenderMeshObservable?.instance || onAfterShadowMapRenderMeshObservable
				onAfterShadowMapRenderMeshObservable = instance.onAfterShadowMapRenderMeshObservable
				if (onAfterShadowMapRenderObservable != undefined) instance.onAfterShadowMapRenderObservable = onAfterShadowMapRenderObservable?.instance || onAfterShadowMapRenderObservable
				onAfterShadowMapRenderObservable = instance.onAfterShadowMapRenderObservable
				if (onBeforeShadowMapRenderMeshObservable != undefined) instance.onBeforeShadowMapRenderMeshObservable = onBeforeShadowMapRenderMeshObservable?.instance || onBeforeShadowMapRenderMeshObservable
				onBeforeShadowMapRenderMeshObservable = instance.onBeforeShadowMapRenderMeshObservable
				if (onBeforeShadowMapRenderObservable != undefined) instance.onBeforeShadowMapRenderObservable = onBeforeShadowMapRenderObservable?.instance || onBeforeShadowMapRenderObservable
				onBeforeShadowMapRenderObservable = instance.onBeforeShadowMapRenderObservable
				if (useOpacityTextureForTransparentShadow != undefined) instance.useOpacityTextureForTransparentShadow = useOpacityTextureForTransparentShadow?.instance || useOpacityTextureForTransparentShadow
				useOpacityTextureForTransparentShadow = instance.useOpacityTextureForTransparentShadow

								// ================ AFRAME PARENT ================

								if (autoParent && !parent) {
									let counter = autoParent
									let parentNode = fieldset
									while( counter > 0 ) {
										parentNode = parentNode.parentNode
										counter-=1
									}
									const parentComponent = $bbLookup.get( parentNode )
									if (parentComponent) {
										instance.parent = parentComponent.instance
										DEBUG('👩‍👦 parent')
									}
								}
								DEBUG('🌴 aframe')
								onLoaded(instance)
							}
						}, 10)
					})
				})


				onDestroy( async e => {
					DEBUG('🔥 destroyed')
					if (instance.dispose) instance.dispose()
				})


				export let autoParent = null
				let fieldset
			</script>
			<svelte:options accessors/>
			<fieldset bind:this={fieldset}>
				<slot />
			</fieldset>

			